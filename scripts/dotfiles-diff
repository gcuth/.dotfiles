#!/usr/bin/env bash
# =============================================================================
# DOTFILES-DIFF - Compare symlinked files with repository versions
# =============================================================================
# Audits symlinks managed by dotbot to detect:
#   - Broken symlinks
#   - Files that have diverged from the repo
#   - Missing expected symlinks
#   - Files that should be symlinks but aren't
#
# Usage:
#   dotfiles-diff              # Show all differences
#   dotfiles-diff --quick      # Only check symlink status (no content diff)
#   dotfiles-diff --fix        # Attempt to fix issues (re-run install)
#   dotfiles-diff <file>       # Check specific file
#   dotfiles-diff --help       # Show help
#
# =============================================================================

set -uo pipefail

# -----------------------------------------------------------------------------
# CONFIGURATION
# -----------------------------------------------------------------------------

readonly DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
readonly INSTALL_CONF="$DOTFILES_DIR/install.conf.yaml"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

# Counters
OK_COUNT=0
WARN_COUNT=0
ERROR_COUNT=0

# -----------------------------------------------------------------------------
# OUTPUT HELPERS
# -----------------------------------------------------------------------------

print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_ok() {
    echo -e "  ${GREEN}✓${NC} $1"
    ((OK_COUNT++))
}

print_warn() {
    echo -e "  ${YELLOW}!${NC} $1"
    ((WARN_COUNT++))
}

print_error() {
    echo -e "  ${RED}✗${NC} $1"
    ((ERROR_COUNT++))
}

print_info() {
    echo -e "  ${CYAN}ℹ${NC} $1"
}

# -----------------------------------------------------------------------------
# SYMLINK EXTRACTION
# -----------------------------------------------------------------------------

# Extract symlink definitions from install.conf.yaml
get_symlinks() {
    # Parse YAML to extract link targets
    # Format: target:source or target: {path: source, ...}
    if command -v python3 &>/dev/null; then
        python3 << 'PYTHON'
import yaml
import os
import sys

config_path = os.path.expanduser("~/.dotfiles/install.conf.yaml")
dotfiles_dir = os.path.expanduser("~/.dotfiles")

try:
    with open(config_path) as f:
        config = yaml.safe_load(f)
except Exception as e:
    sys.exit(0)

for item in config:
    if isinstance(item, dict) and 'link' in item:
        links = item['link']
        for target, source in links.items():
            # Expand ~ in target
            target = os.path.expanduser(target)

            # Handle different source formats
            if isinstance(source, str):
                source_path = source
            elif isinstance(source, dict):
                source_path = source.get('path', '')
                # Skip glob patterns
                if source.get('glob'):
                    continue
            else:
                continue

            if source_path and not '*' in source_path:
                full_source = os.path.join(dotfiles_dir, source_path)
                print(f"{target}|{full_source}")
PYTHON
    else
        # Fallback: basic grep-based extraction (less accurate)
        grep -E '^\s+~' "$INSTALL_CONF" 2>/dev/null | \
            sed 's/:.*//' | \
            sed 's/^\s*//' | \
            while read -r target; do
                echo "${target/#\~/$HOME}|unknown"
            done
    fi
}

# -----------------------------------------------------------------------------
# CHECK FUNCTIONS
# -----------------------------------------------------------------------------

check_symlink() {
    local target="$1"
    local expected_source="$2"
    local show_diff="${3:-true}"

    # Check if target exists
    if [[ ! -e "$target" ]] && [[ ! -L "$target" ]]; then
        print_error "$target (missing)"
        return 1
    fi

    # Check if it's a symlink
    if [[ ! -L "$target" ]]; then
        if [[ -f "$target" ]]; then
            print_warn "$target (regular file, not symlink)"
            if [[ "$show_diff" == "true" ]] && [[ -f "$expected_source" ]]; then
                # Show diff if content differs
                if ! diff -q "$target" "$expected_source" &>/dev/null; then
                    print_info "Content differs from repo version"
                fi
            fi
        else
            print_warn "$target (exists but not a symlink)"
        fi
        return 1
    fi

    # Check symlink target
    local actual_source
    actual_source=$(readlink "$target")

    # Resolve relative paths
    if [[ ! "$actual_source" = /* ]]; then
        actual_source="$(cd "$(dirname "$target")" && cd "$(dirname "$actual_source")" && pwd)/$(basename "$actual_source")"
    fi

    # Compare sources
    if [[ "$actual_source" == "$expected_source" ]]; then
        print_ok "$target"
        return 0
    else
        # Check if they resolve to the same file
        local resolved_actual resolved_expected
        resolved_actual=$(realpath "$target" 2>/dev/null || echo "")
        resolved_expected=$(realpath "$expected_source" 2>/dev/null || echo "")

        if [[ -n "$resolved_actual" ]] && [[ "$resolved_actual" == "$resolved_expected" ]]; then
            print_ok "$target (via different path)"
            return 0
        else
            print_warn "$target → $actual_source (expected: $expected_source)"
            return 1
        fi
    fi
}

check_all_symlinks() {
    local quick_mode="$1"

    print_header "Symlink Audit"

    local symlinks
    symlinks=$(get_symlinks)

    if [[ -z "$symlinks" ]]; then
        print_warn "Could not parse symlinks from install.conf.yaml"
        print_info "Ensure python3 and PyYAML are installed"
        return
    fi

    while IFS='|' read -r target source; do
        [[ -z "$target" ]] && continue
        check_symlink "$target" "$source" "$([[ "$quick_mode" == "true" ]] && echo "false" || echo "true")"
    done <<< "$symlinks"
}

check_git_status() {
    print_header "Repository Status"

    if [[ ! -d "$DOTFILES_DIR/.git" ]]; then
        print_error "Not a git repository: $DOTFILES_DIR"
        return
    fi

    # Check for uncommitted changes
    local status
    status=$(git -C "$DOTFILES_DIR" status --porcelain 2>/dev/null)

    if [[ -z "$status" ]]; then
        print_ok "Working tree clean"
    else
        local modified added deleted untracked
        modified=$(echo "$status" | grep -c '^ M' || echo 0)
        added=$(echo "$status" | grep -c '^A' || echo 0)
        deleted=$(echo "$status" | grep -c '^ D' || echo 0)
        untracked=$(echo "$status" | grep -c '^??' || echo 0)

        [[ $modified -gt 0 ]] && print_warn "$modified modified file(s)"
        [[ $added -gt 0 ]] && print_info "$added staged file(s)"
        [[ $deleted -gt 0 ]] && print_warn "$deleted deleted file(s)"
        [[ $untracked -gt 0 ]] && print_info "$untracked untracked file(s)"
    fi

    # Check if ahead/behind remote
    local upstream
    upstream=$(git -C "$DOTFILES_DIR" rev-parse --abbrev-ref '@{upstream}' 2>/dev/null || echo "")

    if [[ -n "$upstream" ]]; then
        local ahead behind
        ahead=$(git -C "$DOTFILES_DIR" rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo 0)
        behind=$(git -C "$DOTFILES_DIR" rev-list --count 'HEAD..@{upstream}' 2>/dev/null || echo 0)

        if [[ $ahead -gt 0 ]]; then
            print_info "$ahead commit(s) ahead of $upstream"
        fi
        if [[ $behind -gt 0 ]]; then
            print_warn "$behind commit(s) behind $upstream"
        fi
        if [[ $ahead -eq 0 ]] && [[ $behind -eq 0 ]]; then
            print_ok "Up to date with $upstream"
        fi
    else
        print_info "No upstream configured"
    fi
}

check_single_file() {
    local file="$1"

    # Expand path
    file="${file/#\~/$HOME}"
    [[ ! "$file" = /* ]] && file="$PWD/$file"

    print_header "Checking: $file"

    if [[ -L "$file" ]]; then
        local target
        target=$(readlink "$file")
        print_info "Symlink → $target"

        if [[ -e "$file" ]]; then
            print_ok "Target exists"
        else
            print_error "Broken symlink (target does not exist)"
        fi
    elif [[ -f "$file" ]]; then
        print_info "Regular file (not a symlink)"

        # Try to find corresponding repo file
        local basename
        basename=$(basename "$file")
        local repo_file
        repo_file=$(find "$DOTFILES_DIR" -name "$basename" -type f 2>/dev/null | head -1)

        if [[ -n "$repo_file" ]]; then
            print_info "Found in repo: $repo_file"
            if diff -q "$file" "$repo_file" &>/dev/null; then
                print_ok "Content matches repo version"
            else
                print_warn "Content differs from repo version"
                echo
                echo "Diff (file vs repo):"
                diff --color=auto "$file" "$repo_file" 2>/dev/null || diff "$file" "$repo_file"
            fi
        fi
    elif [[ -e "$file" ]]; then
        print_info "Exists but not a regular file"
    else
        print_error "File does not exist"
    fi
}

# -----------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------

print_usage() {
    cat << 'EOF'
Usage: dotfiles-diff [OPTIONS] [FILE]

Audit dotfiles symlinks and detect differences from repository.

Options:
  --quick     Only check symlink status (skip content comparison)
  --fix       Attempt to fix issues by re-running install
  --help, -h  Show this help message

Arguments:
  FILE        Check a specific file instead of all symlinks

Examples:
  dotfiles-diff              # Full audit of all symlinks
  dotfiles-diff --quick      # Quick check without content diff
  dotfiles-diff ~/.zshrc     # Check specific file
  dotfiles-diff --fix        # Fix issues by re-running install
EOF
}

main() {
    local quick_mode=false
    local fix_mode=false
    local single_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quick|-q)
                quick_mode=true
                shift
                ;;
            --fix|-f)
                fix_mode=true
                shift
                ;;
            --help|-h)
                print_usage
                exit 0
                ;;
            -*)
                echo "Unknown option: $1"
                print_usage
                exit 1
                ;;
            *)
                single_file="$1"
                shift
                ;;
        esac
    done

    echo -e "${BLUE}"
    echo "╔════════════════════════════════════════╗"
    echo "║       DOTFILES DIFF / AUDIT            ║"
    echo "╚════════════════════════════════════════╝"
    echo -e "${NC}"

    if [[ -n "$single_file" ]]; then
        check_single_file "$single_file"
    else
        check_git_status
        check_all_symlinks "$quick_mode"
    fi

    # Summary
    print_header "Summary"
    echo -e "  ${GREEN}OK:${NC}       $OK_COUNT"
    echo -e "  ${YELLOW}Warnings:${NC} $WARN_COUNT"
    echo -e "  ${RED}Errors:${NC}   $ERROR_COUNT"
    echo

    # Fix mode
    if [[ "$fix_mode" == true ]] && [[ $((WARN_COUNT + ERROR_COUNT)) -gt 0 ]]; then
        echo -e "${BLUE}Attempting to fix issues...${NC}"
        echo

        if [[ -x "$DOTFILES_DIR/install" ]]; then
            "$DOTFILES_DIR/install"
            echo
            echo -e "${GREEN}Re-run 'dotfiles-diff' to verify fixes.${NC}"
        else
            echo -e "${RED}Cannot find install script at $DOTFILES_DIR/install${NC}"
            exit 1
        fi
    elif [[ $ERROR_COUNT -gt 0 ]]; then
        echo -e "${RED}Issues detected. Run with --fix to attempt repairs.${NC}"
        exit 1
    elif [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}Audit completed with warnings.${NC}"
        exit 0
    else
        echo -e "${GREEN}All checks passed!${NC}"
        exit 0
    fi
}

main "$@"
