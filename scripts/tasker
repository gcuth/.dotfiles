#!/usr/bin/env bb
;
; Interface with todoist & toggl to display, generate, and manage best tasks.
;
; show best todoist task (to do) by calling todoist-cli, or current toggl status
; if there's an active toggl project/task (checks both)

(require '[clojure.java.shell :refer [sh]]
         '[clojure.java.io :as io])

(def unique-inputs (dedupe *command-line-args*))

(def bp-log-path "/home/g/Documents/blog/data/logs/bp.csv")
(def mood-log-path "/home/g/Documents/blog/data/logs/mood.csv")
(def to-mail-path "/home/g/Documents/blog/data/tomail.txt")
(def to-message-path "/home/g/Documents/blog/data/tomessage.txt")
(def current-wifi (:out (sh "iwgetid" "-r"))) ; the name of the wifi I'm connected to
(def home? (some? (re-find #"tell-my-wifi-love-her" current-wifi))) ; if connected to home wifi

(def overload-threshold 5) ; if more than this many tasks due today, get worried
(def work-late? false) ; a switch for whether to care about hours in best-task etc

(def messages-per-day ; so that everybody on the list gets a message regularly, even as the list grows
  (quot (count (set (line-seq (io/reader to-message-path)))) 7))

(def person-to-mail (rand-nth (line-seq (io/reader to-mail-path))))
(def person-to-message (rand-nth (line-seq (io/reader to-message-path))))

; UTILITY FUNCTIONS
(defn csv-data->maps [csv-data]
  (map zipmap
       (->> (first csv-data) ;; First row is the header
            (map keyword) ;; Drop if you want string keys instead
            repeat)
	  (rest csv-data)))

(defn mean [coll]
  (let [sum (apply + coll)
        count (count coll)]
    (if (pos? count)
      (/ sum count)
      0)))

(defn in?
  "true if coll contains elm"
  [coll elm]
  (some #(= elm %) coll))


; CURRENT ENVIRONMENT/SITUATION
(def work-hours?
  (let [now (Integer/parseInt (str/trim (:out (sh "date" "+%H"))))]
    (<= 8 now 16)))

(def active-hours?
  (let [now (Integer/parseInt (str/trim (:out (sh "date" "+%H"))))]
    (<= 5 now 19)))

(def morning-hours?
  (let [now (Integer/parseInt (str/trim (:out (sh "date" "+%H"))))]
    (<= 5 now 9)))

(def hours-since-bp-log ; checks the last datetime of a blood pressure log
  (if (.exists (io/file bp-log-path))
    (int (/ (- (.getTime (java.util.Date.))
               (.lastModified (java.io.File. bp-log-path)))
            1000 60 60))
    24))

(def hours-since-mood-log ; checks the last datetime of a mood log
  (if (.exists (io/file mood-log-path))
    (int (/ (- (.getTime (java.util.Date.))
               (.lastModified (java.io.File. mood-log-path)))
            1000 60 60))
    24))


; TODOIST FUNCTIONS
(defn get-sorted-tasks [todoist-results]
  (sort-by :Priority (into [] (-> todoist-results
                                  (:out)
                                  (csv/read-csv)
                                  (csv-data->maps)))))

(defn is-work-project? "Check whether a project is a work task" [project]
  (or (some? (re-find (re-pattern "Thesis") project))
      (some? (re-find (re-pattern "Work") project))
      (some? (re-find (re-pattern "Read All About It") project))
      (some? (re-find (re-pattern "Antarctic Treaty Papers") project))
      (some? (re-find (re-pattern "Reading at the Interface") project))
      (some? (re-find (re-pattern "Digital Literary Literacy") project))))

(defn has-work-label? "Check a list of labels for 'work'" [labels]
  (not= 0 (count (remove nil?
                         (into []
                               (map #(re-find (re-pattern "work") %)
                                    labels))))))

(defn is-exercise-project? "Check whether a project is an exercise task" [project]
  (or (some? (re-find (re-pattern "Run") project))
      (some? (re-find (re-pattern "Exercise") project))))

(defn has-exercise-label? "Check a list of labels for 'exercise'" [labels]
  (not= 0 (count (remove nil?
                         (into []
                               (map #(re-find (re-pattern "exercise") %)
                                    labels))))))


(defn is-work-task? "Check whether a task is a work task" [task]
  (or (is-work-project? (:Project task))
      (has-work-label? (:Labels task))))

(defn is-exercise-task? "Check whether a task is an exercise task" [task]
  (or (is-exercise-project? (:Project task))
      (has-exercise-label? (:Labels task))))

(defn remove-work-tasks "Remove all tasks that are work tasks from task list" [tasks]
  (remove is-work-task? tasks))

(defn has-exercise-label? "Check a list of labels for 'exercise'" [labels]
  (not= 0 (count (remove nil?
                         (into []
                               (map #(re-find (re-pattern "exercise") %)
                                    labels))))))

(defn is-exercise-project? "Check whether a project is an exercise task" [project]
  (or (some? (re-find (re-pattern "Exercise") project))
      (some? (re-find (re-pattern "Run") project))))

(defn is-exercise-task? "Check whether a task is an exercise task" [task]
  (or (is-exercise-project? (:Project task))
      (has-exercise-label? (:Labels task))))

(defn remove-exercise-tasks "Remove all tasks from exercise projects" [tasks]
  (remove is-exercise-task? tasks))

; CURRENT TODOIST
(def today (get-sorted-tasks (sh "/usr/local/bin/todoist"
                                   "--csv" "--header"
                                   "list" "--filter" "(today|overdue)")))

(def other-tasks (get-sorted-tasks (sh "/usr/local/bin/todoist"
                                       "--csv" "--header" "list" "--priority")))

(def has-due (remove #(str/blank? (:Date %)) other-tasks))

(def completed (sort-by :CompletedDate (into [] (-> (sh "/usr/local/bin/todoist"
                                                        "--csv" "--header"
                                                        "completed-list")
                                                    (:out)
                                                    (csv/read-csv)
                                                    (csv-data->maps)))))

(def completed-today (sort-by :CompletedDate (into [] (-> (sh "/usr/local/bin/todoist"
                                                        "--csv" "--header"
                                                        "completed-list"
                                                        "--filter" "(today)")
                                                    (:out)
                                                    (csv/read-csv)
                                                    (csv-data->maps)))))

(def current-work-task-percentage ; the percentage of completed tasks that are work tasks
  (let [total-tasks (count completed)
        n-work-tasks (count (filter is-work-task? completed))]
    (/ n-work-tasks total-tasks)))

(def last-task-was-a-work-task?
  (is-work-task? (last completed)))

(def last-task-was-exercise?
  (is-exercise-task? (last completed)))

(def best-task
  (let [overworked? (if work-hours?
                      (> current-work-task-percentage 2/5)
                      (> current-work-task-percentage 1/5))
        just-beginning? (= 0 (count completed-today))
        overwhelmed? false]
    (cond just-beginning?
            (first (remove nil? (conj []
                                      (first (filter #(= "Thesis" (:Project %)) has-due))
                                      (first today)
                                      (first has-due)
                                      (first other-tasks))))
          (and (not overworked?) (not overwhelmed?) (not last-task-was-a-work-task?))
            (if (not last-task-was-exercise?)
              (first (remove nil? (conj []
                                        (first today)
                                        (first has-due)
                                        (first other-tasks))))
              (first (remove nil? (conj []
                                        (first (remove-exercise-tasks today))
                                        (first (remove-exercise-tasks has-due))
                                        (first (remove-exercise-tasks other-tasks))))))
          :else
            (first (remove nil? (conj []
                                      (first (filter #(= "Thesis" (:Project %)) today))
                                      (first (remove-work-tasks today))
                                      (first (remove-work-tasks has-due))
                                      (first (remove-work-tasks other-tasks))))))))




; CURRENT TOGGL INFO
(def toggl-now (sh "/usr/local/bin/toggl" "now"))

(def current-toggl-task (-> toggl-now
                            (:out)
                            (str/split #"#")
                            (first)
                            (str/trim)
                            (str/trim-newline)))

(defn active-toggl? [] (not (= current-toggl-task "There is no time entry running!")))



; TASK CONDITIONS (BASED ON TODOIST & TOGGL)

(def do-pushups?
  (and active-hours?
       (= 0 (count (filter #(re-find #"pushups" (:Content %)) today)))
       (> 10 (count (filter #(re-find #"pushups" (:Content %)) completed-today)))))

(def do-pullups?
  (and active-hours?
       home?
       (= 0 (count (filter #(re-find #"pullups" (:Content %)) today)))
       (> 5 (count (filter #(re-find #"pullups" (:Content %)) completed-today)))))

(def do-anki?
  (and (= 0 (count (filter #(re-find (re-pattern "Anki") (:Project %)) today)))
       (= 0 (count (filter #(re-find (re-pattern "Anki") (:Project %)) completed-today)))))

(def do-journal?
  (and (not work-hours?)
       morning-hours?
       (= 0 (count (filter #(re-find (re-pattern "Blog") (:Project %)) today)))
       (= 0 (count (filter #(re-find (re-pattern "Blog") (:Project %)) completed-today)))))

(def do-forecast?
  (and (not work-hours?)
       (= 0 (count (filter #(re-find (re-pattern "Predict") (:Project %)) today)))
       (= 0 (count (filter #(re-find (re-pattern "Predict") (:Project %)) completed-today)))))

(def log-bp?
  (and (> hours-since-bp-log 4)
       (= 0 (count (filter #(re-find (re-pattern "Log") (:Project %)) today)))))

(def log-mood?
  (and (> hours-since-mood-log 2)
       (= 0 (count (filter #(re-find (re-pattern "Log") (:Project %)) today)))))

(def run-roomba?
  (and home?
       active-hours?
       (= 0 (count (filter #(re-find #"roomba" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"roomba" (:Content %)) completed-today)))))

(def clean-kitchen?
  (and home?
       (= 0 (count (filter #(re-find #"kitchen" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"kitchen" (:Content %)) completed-today)))))

(def cook-dinner?
  (and home?
       (not work-hours?)
       active-hours?
       (= 0 (count (filter #(re-find #"Cook dinner" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"Cook dinner" (:Content %)) completed-today)))))

(def send-postcard?
  (and active-hours?
       (= 0 (count (filter #(re-find #"Send postcard" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"Send postcard" (:Content %)) completed-today)))))

(def send-message?
  (and active-hours?
       (= 0 (count (filter #(re-find (re-pattern person-to-message) (:Content %)) today)))
       (= 0 (count (filter #(re-find (re-pattern person-to-message) (:Content %)) completed-today)))
       (> messages-per-day (count (filter #(re-find #"Send message" (:Content %)) today)))
       (> messages-per-day (count (filter #(re-find #"Send message" (:Content %)) completed-today)))))

(def too-many-tasks?
  (> (count today) overload-threshold))

(def flag-too-many?
  (and too-many-tasks?
       (= 0 (count (filter #(re-find #"Restructure tasklist for today" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"Restructure tasklist for today" (:Content %)) completed-today)))))

(def flag-not-enough?
  (and (= 0 (count today))
       (= 0 (count (filter #(re-find #"Generate habitual tasks for the day" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"Generate habitual tasks for the day" (:Content %)) completed-today)))))

(def check-newsboat?
  (and work-hours?
       (= 0 (count (filter #(re-find #"newsboat" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"newsboat" (:Content %)) completed-today)))))

(def meditate?
  (and (= 0 (count (filter #(re-find #"Meditate" (:Content %)) today)))
       (= 0 (count (filter #(re-find #"Meditate" (:Content %)) completed-today)))))

; TASK VARIABLES

(def average-pushups
  (->> completed
       (filter #(re-find #"pushups" (:Content %)))
       (map #(re-find #"\d+" (:Content %)))
       (concat)
       (remove nil?)
       (map #(Integer/parseInt %))
       (mean)
       (float)
       (Math/round)))

(def average-pullups
  (->> completed
       (filter #(re-find #"pullups" (:Content %)))
       (map #(re-find #"\d+" (:Content %)))
       (concat)
       (remove nil?)
       (map #(Integer/parseInt %))
       (mean)
       (float)
       (Math/round)
       (int)))

(def best-pullups
  (rand-nth (list (max 1 (min 20 (+ 1 average-pullups)))
                  (max 1 (min 20 average-pullups))
                  (max 1 (min 20 average-pullups)))))

(def best-pushups
  (rand-nth (list (* 5 (Math/round (float (/ average-pushups 5))))
                  (min 100 (* 5 (Math/round (float (/ (+ 2.5 average-pushups) 5)))))
                  10)))




; TARGETS FOR MANAGING TODOIST STOP & TOGGL SYNC
(defn stop-toggl []
  "Stop toggl tracker by calling cli"
  (sh "/usr/local/bin/toggl" "stop"))

(defn sync-todoist []
  "Sync current todoist data with remote"
  (sh "/usr/local/bin/todoist" "sync"))

; COMPLETE TODOIST TASK ASSOCIATED WITH CURRENT TOGGL
(defn mark-a-task-done [task]
  "Mark some todoist task done"
  (sh "/usr/local/bin/todoist" "close" (:ID task)))

(defn mark-current-done []
  "If it's actively tracking on todoist, mark the current todoist
   'best task' done (& stop toggl & sync todoist)"
  (if (= current-toggl-task (:Content best-task))
    (do (mark-a-task-done best-task)
        (stop-toggl)
        (sync-todoist))))

; START CURRENT BEST TASK AS TOGGL
(defn start-toggl-for-task [task]
  "Start toggl tracker for some todoist task"
  (let [project (first (str/split (str/replace (:Project task) "#" "") #"\/"))
        task (:Content task)]
    (sh "/usr/local/bin/toggl" "start" "-o" project task)))

; DISPLAY STATUS
(defn display-status []
  (let [n-left (count today)
        status (if (active-toggl?)
                     (str/join "" ["[~] " current-toggl-task])
                     (str/join "" ["(" n-left ") " "[ ] " (:Content best-task)]))]
     (if (not (active-toggl?))
         (do (println status)
             (println status)
             (println "#FF0000"))
         (println status))))

; GENERATE
(defn add-task "Send a system call to add a task to todoist"
  [task project-name date priority]
  (sh "/usr/local/bin/todoist" "add"
      "--priority" (str priority)
      "--date" date
      "--project-name" project-name
      task))

(defn add-best-task []
  (cond (true? flag-too-many?) (add-task "Restructure tasklist for today" "Life Admin" "today" 1)
        (true? flag-not-enough?) (add-task "Generate habitual tasks for the day" "Life Admin" "today" 1)
        (true? meditate?) (add-task "Meditate" "Tekke" "today" 1)
        (true? do-journal?) (add-task "Write morning pages"
                                      "Blog" "today" 4)
        (true? log-mood?) (add-task "Log mood"
                                    "Log" "today" 4)
        (true? do-pullups?) (add-task (str/join " " ["Do"
                                                     (str best-pullups)
                                                     "pullups"])
                                      "Exercise" "today" 3)
        (true? do-pushups?) (add-task (str/join " " ["Do"
                                                     (str best-pushups)
                                                     "pushups"])
                                      "Exercise" "today" 3)
        (true? do-anki?) (add-task "Complete all anki decks"
                                   "Anki" "today" 4)
        (true? do-forecast?) (add-task "Update metaculus forecasts"
                                       "Predict" "today" 4)
        (true? log-bp?) (add-task "Log blood pressure"
                                  "Log" "today" 3)
        (true? run-roomba?) (add-task "Turn on roomba" "Clean" "today" 4)
        (true? clean-kitchen?) (add-task "Clean the kitchen" "Clean" "today" 4)
        (true? cook-dinner?) (add-task "Cook dinner" "Cook" "today" 4)
        (true? send-message?) (add-task (str/join ["Send message to "
                                                   person-to-message])
                                        "Social" "today" 4)
        (true? send-postcard?) (add-task (str/join ["Send postcard to "
                                                   person-to-mail])
                                        "Social" "today" 4)
        (true? check-newsboat?) (add-task "Add all interesting new articles from newsboat" "Read" "today" 4)
        ;; (true? cut-hair?) (add-task "Cut hair" "Life Admin" "today" 3)
        ))

; MAIN
(let [inputs unique-inputs]
  (cond (in? inputs "stop") (do (stop-toggl))
        (in? inputs "sync") (do (sync-todoist))
        (in? inputs "start") (do (start-toggl-for-task best-task))
        (in? inputs "complete") (if (and (active-toggl?)
                                         (= current-toggl-task (:Content best-task)))
                                  (do (mark-current-done)))
        (in? inputs "status") (display-status)
        (in? inputs "generate") (add-best-task)
        (in? inputs "test") (println messages-per-day)
        :else (display-status))) ; display status by default
